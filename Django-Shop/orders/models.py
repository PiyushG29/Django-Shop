import uuid
from decimal import Decimal
from typing import Optional

from django.conf import settings
from django.db import models, transaction
from django.urls import reverse
from payments import PaymentStatus, PurchasedItem
from payments.models import BasePayment

from products.models import Product


def generate_order_number() -> str:
    """Generate a unique human-friendly order number.

    Uses a UUID4 hex string prefixed with 'ORD-'. Example: 'ORD-3f5a...'.
    """
    return f"ORD-{uuid.uuid4().hex}"


class Order(models.Model):
    STATUS_CHOICES = [
        ("pending", "Pending"),
        ("processing", "Processing"),
        ("shipped", "Shipped"),
        ("delivered", "Delivered"),
        ("cancelled", "Cancelled"),
    ]

    user = models.ForeignKey(
        settings.AUTH_USER_MODEL, on_delete=models.CASCADE, related_name="order_set"
    )
    order_number = models.CharField(
        max_length=40, unique=True, default=generate_order_number, editable=False
    )
    status = models.CharField(max_length=20, choices=STATUS_CHOICES, default="pending")
    shipping_address = models.ForeignKey(
        "users.Address",
        on_delete=models.SET_NULL,
        null=True,
        related_name="order_shipping_set",
    )
    billing_address = models.ForeignKey(
        "users.Address",
        on_delete=models.SET_NULL,
        null=True,
        related_name="order_billing_set",
    )
    total_amount = models.DecimalField(max_digits=10, decimal_places=2)
    payment_status = models.CharField(
        max_length=20, choices=PaymentStatus.CHOICES, default=PaymentStatus.WAITING
    )
    paid_at = models.DateTimeField(null=True, blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    class Meta:
        ordering = ["-created_at"]

    def __str__(self):
        return f"Order {self.order_number}"

    @property
    def total(self) -> Decimal:
        # Keep a convenient property aligning with payments API naming
        return self.total_amount

    @property
    def is_paid(self) -> bool:
        return self.payment_status == PaymentStatus.CONFIRMED

    # --- Domain operations (fat model pattern) ---
    @classmethod
    @transaction.atomic
    def create_from_cart(cls, *, cart, user) -> "Order":
        """Create an Order snapshot from a Cart for the given user.

        - Picks user's primary Address for both shipping and billing if available.
        - Snapshots current unit prices into OrderItem.price.
        - Computes and persists the order total.
        """
        # Lazy imports to avoid circular deps at import time
        from users.models import Address  # noqa: WPS433

        if not cart.total_quantity:
            raise ValueError("Cannot create an order from an empty cart")

        # Choose primary address if available; else None
        primary_addr: Optional[Address] = Address.objects.filter(
            user=user, is_primary=True
        ).first()

        # Create order shell (order_number generated by default)
        order = cls.objects.create(
            user=user,
            status="pending",
            shipping_address=primary_addr,
            billing_address=primary_addr,
            total_amount=Decimal(cart.total),
        )

        # Snapshot items (unit price at time of order)
        bulk_items = []
        for item in cart.items:
            bulk_items.append(
                OrderItem(
                    order=order,
                    product=item.product,
                    quantity=item.quantity,
                    price=Decimal(item.unit_price),
                )
            )
        OrderItem.objects.bulk_create(bulk_items)

        # Recompute total from items to ensure consistency
        total = sum((oi.price * oi.quantity for oi in order.items.all()), Decimal("0"))
        if total != order.total_amount:
            order.total_amount = total
            order.save(update_fields=["total_amount", "updated_at"]) if hasattr(
                order, "updated_at"
            ) else order.save(update_fields=["total_amount"])  # pragma: no cover

        return order


class OrderItem(models.Model):
    order = models.ForeignKey(Order, on_delete=models.CASCADE, related_name="items")
    product = models.ForeignKey(
        Product, on_delete=models.CASCADE, related_name="order_items"
    )
    quantity = models.PositiveIntegerField()
    price = models.DecimalField(max_digits=10, decimal_places=2)
    created_at = models.DateTimeField(auto_now_add=True)

    @property
    def total(self):
        return self.price * self.quantity

    def __str__(self):
        return f"{self.quantity} x {self.product.name}"


class Payment(BasePayment):
    """Payment record managed by django-payments, attached to an Order."""

    order = models.ForeignKey(
        "orders.Order", on_delete=models.PROTECT, related_name="payments"
    )

    def _absolute(self, path: str) -> str:
        host = getattr(settings, "PAYMENT_HOST", "").rstrip("/")
        use_ssl = getattr(
            settings, "PAYMENT_USES_SSL", not getattr(settings, "DEBUG", False)
        )
        scheme = "https" if use_ssl else "http"
        return f"{scheme}://{host}{path}" if host else path

    def get_failure_url(self) -> str:
        return self._absolute(reverse("orders:payment_failed", args=[self.order_id]))

    def get_success_url(self) -> str:
        return self._absolute(reverse("orders:payment_success", args=[self.order_id]))

    def get_purchased_items(self):
        # Charge the full order as a single line; keeps provider-agnostic and simple
        yield PurchasedItem(
            name=f"Order #{self.order.order_number}",
            sku=f"ORDER-{self.order_id}",
            quantity=1,
            price=Decimal(self.total),
            currency=self.currency,
        )
